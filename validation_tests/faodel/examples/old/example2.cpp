// Copyright 2018 National Technology & Engineering Solutions of Sandia, 
// LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS,  
// the U.S. Government retains certain rights in this software. 

#include <iostream>
#include <unistd.h>
#include <assert.h>

#include "faodel-common/Common.hh"
#include "opbox/OpBox.hh"

#include "opbox/services/dirman/DirectoryManager.hh"

#include "Globals.hh"

using namespace std;
using namespace faodel;
using namespace opbox;

extern Globals G;

//The node that creates the directory can also volunteer other nodes to
//participate as its members. This is handy for quick-and-dirty situations
//where some configuration engine knows everything and allocates resources.
void example2_prepopulate_with_members(){

  string dir_path="/prepopulated/with/stuff";
  string dir_info="Volunteered Nodes";
  DirectoryInfo dir;
  bool ok;

  //Have host create the item
  if(G.mpi_rank==0){

    cout <<"\nExample 2: Prepopulate with members\n";


    DirectoryInfo src_dir(dir_path, dir_info);

    //We can supply some nodes here and give them names
    //note: In order to generate some bogus nodeid's here, we're using the
    //      internal_use_only ctor for nodeid_t. Node ids are always
    //      generated by the libs for you, unless you're debugging like this.
    src_dir.Join( faodel::nodeid_t(200, internal_use_only), "SomeNode");
    src_dir.Join( faodel::nodeid_t(201, internal_use_only), "AnotherNode");

    //We can also plug in nodes annonymously and have it generate a name
    for(int i=100; i<105; i++)
      src_dir.Join( faodel::nodeid_t(i, internal_use_only)); //No label means autogen it

    ok = dirman::HostNewDir(src_dir);
    assert(ok && "Root couldn't host a new directory?");
  }

  //Wait until the item is created
  MPI_Barrier(MPI_COMM_WORLD);

  //Have each node grab the directory
  ok = dirman::GetDirectoryInfo(ResourceURL(dir_path), &dir);
  assert(ok && "Node could not retrieve directory");

  cout <<"Info: '"<<dir.info
       <<"' ReferenceNode: " <<dir.GetReferenceNode().GetHex()
       <<" NumberMembers: " <<dir.members.size()<<endl;

  MPI_Barrier(MPI_COMM_WORLD);

  if(G.mpi_rank==G.mpi_size-1){
    cout <<"Rank "<<G.mpi_rank<<" sees the following members:\n";
    for(auto &name_node : dir.members){
      cout <<"     "<<name_node.name
           <<"  "<<name_node.node.GetHex() <<endl;
    }
  }

  MPI_Barrier(MPI_COMM_WORLD);

}
